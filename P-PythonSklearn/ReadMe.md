# Overview

In this section you will learn what Jupiter Notebook is and how to use it.
And also get acquainted with such useful libraries as:
1. _NumPy_
1. _Pandas_
1. _Matplotlib_
1. _Seaborn_
1. _Scikit-learn_

You will learn how to work with types such as **Series** and **DataFrame** that make it easier to work with data and make it easy to manipulate that data (_add, delete, modify, filter_) and learn how to draw different graphs based on your data.

## Подробности

### NumPy

Главной особенностью **NumPy** является объект **array (массив)**.
_Массивы_ похожи на _списки_ в _Python_, если исключить тот факт, что _элементы массива должны иметь_ ___одинаковый___ _тип данных_ (например: **float** или **int**).
С _массивами_ можно проводить числовые операции с большим объёмом информации **в разы быстрее и намного эффективнее** чем со _списками_.

Существует множество способов создания _массива_.
Если у Вас есть _список_, а Вы хотите преобразовать его в _массив_, то для этого подойдёт метод `array()`, если же Вам нужен _массив_ заполненный нулями, то для этого есть метод `zeros()`, кроме этих методов есть и другие, которые позволяют очень быстро создать _массив_ с необходимыми данными.
Ниже представлены некоторые из них:
```python
>>> Z = numpy.array([1, 2, 3, 4])
>>> Z
array([1, 2, 3, 4])

>>> Z = numpy.zeros(10)
>>> Z
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

>>> Z = numpy.random.random((3,4))
>>> Z
array([[0. , 0.3, 0.6, 0.8],
       [0.5, 0.2, 0.5, 0.9],
       [0. , 0.7, 0.6, 0.9]])

>>> Z = numpy.arange(start=0, stop=1, step=0.3, dtype=float)
>>> Z
array([0. , 0.3, 0.6, 0.9])
```

Каждый _массив_ имеет, так называемую, ___форму___ - это размерность массива.
Например _вектор_ имеет _форму_ = `(x,)`, что соответствует одномерному _массиву_ в котором находится ___x___ элементов, а матрица имеющая ___x___ строк и ___y___ столбцов _форма_ = `(x, y)`.

Если в процессе работы Вам потребовалось изменить _форму массива_, то для этого необязательно создавать новый _массив_ необходимой размерности и с помощью хитрого цикла заполнять его.
В _NumPy_ есть метод `reshape()`, который изменяет _форму_ на нужную.
С помощью данного метода можно легко изменить **вектор (одномерный массив)** в **матрицу (многомерный массив)** и наоборот:
```python
>>> a = numpy.array(range(10), float)
>>> a
array([ 0.,  1.,  2., 3.,  4.,  5.,  6.,  7.,  8.,  9.])
>>> a = a.reshape((5, 2))
>>> a
array([[ 0.,  1.],
[ 2.,  3.],
[ 4.,  5.],
[ 6.,  7.],
[ 8.,  9.]])
```

Также _NumPy_ позволяет, с помощью метода `transpose()`, легко транспонировать _матрицы_:
```python
>>> a = numpy.array(range(6), float).reshape((2, 3))
>>> a
array([[ 0.,  1.,  2.],
[ 3.,  4.,  5.]])
>>> a.transpose()
array([[ 0.,  3.],
[ 1.,  4.],
[ 2.,  5.]])
```

Если вдруг Вам понадобится создать **единичную матрицу** (квадратная матрица, в которой элементы главной диагонали равны **1**, а остальные равны **0**), то можно воспользоваться методом `identity()`:
```python
>>> numpy.identity(4, dtype=float)
array([[ 1.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.],
       [ 0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  1.]])
```

Это лишь малая часть того, что умеет **NumPy**.

---

### Pandas

___Pandas___ — это библиотека _Python_, предоставляющая широкие возможности для анализа данных.

Основными структурами данных в _Pandas_ являются классы _Series_ и _DataFrame_.
___Series___ - это одномерный индексированный массив данных некоторого фиксированного типа.
___DataFrame___ – это двухмерная структура данных, представляющая собой таблицу, каждый столбец которой содержит данные одного типа.
Можно представлять её как словарь объектов типа _Series_.
Структура _DataFrame_ отлично подходит для представления реальных данных: строки соответствуют признаковым описаниям отдельных объектов, а столбцы соответствуют признакам.

Существует множество способов создания _series_ и _DataFrame_.
Если у Вас есть _список_ или _массив_, а Вы хотите преобразовать его в _Series_, то для этого подойдёт метод `Series()`:
```python
>>> s = pd.Series([1, 2, 3, 4, 5])
>>> s
0    1
1    2
2    3
3    4
4    5
dtype: int64

>>> ndarr = numpy.array([1, 2, 3, 4, 5])
>>> s = pd.Series(ndarr)
>>> s
0    1
1    2
2    3
3    4
4    5
dtype: int64
```

Создать _DataFrame_ можно с помощью _Series, словаря, списка словарей, n-мерного массива_.
Например:
```python
>>> ndarr = numpy.array([[1, 2, 3], [10, 20, 30]])
>>> df = pandas.DataFrame(ndarr)
>>> df
    0   1   2
0   1   2   3
1   10  20  30
```

_DataFrame_ предоставляет огромный набор для манипулирования данными.
Он может _добавлять, удалять, изменять, фильтровать, группировать_ и ещё много-много всего того, что может Вам понадобится.
Несколько примеров:
```python
>>> d = {"price": numpy.array([1, 2, 3]),
...      "count": numpy.array([10, 20, 30])}
>>> df = pandas.DataFrame(d, index=['a', 'b', 'c'])
>>> df
    count   price
a   10      1
b 	20      2
c 	30      3

>>> df['count']
a    10
b    20
c    30
Name: count, dtype: int64

>>> df.loc['a']
count    10
price     1
Name: a, dtype: int64

>>> df.iloc[1]
count    20
price     2
Name: b, dtype: int64

>>> df[0:2]
    count   price
a 	10      1
b 	20      2

>>> df[df['count'] >= 20]
    count   price
b 	20      2
c 	30      3
```

И это ещё не всё, на что способна эта, замечательная, библиотека.

---

### Matplotlib

___Matplotlib___ - это библиотека для визуализации данных.

С помощью данной библиотеки можно строить какие-либо сложные графики, поскольку она позволяет очень гибко настраивать графики.
На графике можно изменить почти всё, что угодно, но для этого потребуется порыться в документации и найти нужные параметры.
Например, параметр `rot` отвечает за угол наклона подписей к оси **X**.

Вот несколько примеров графиков, которые Вы сможете построить с помощью _matplotlib_:
![matplotlib-01]("../images/part01_matplotlib_01.png")

![matplotlib-02]("../images/part01_matplotlib_02.png")

![matplotlib-03]("../images/part01_matplotlib_03.png")

---

### Seaborn

___Seaborn___ - это библиотека для визуализации данных, которая, по сути, представляет собой более высокоуровневое API на базе библиотеки _matplotlib_.
_Seaborn_ содержит более адекватные дефолтные настройки оформления графиков.
Также в библиотеке есть достаточно сложные типы визуализации, которые в _matplotlib_ потребовали бы большого количество кода.

Ниже Вы найдёте несколько примеров графиков, которые можно построить с помощью _seaborn_:
![seaborn-01]("../images/part01_seaborn_01.png")

![seaborn-02]("../images/part01_seaborn_02.png")

![seaborn-03]("../images/part01_seaborn_03.png")

![seaborn-04]("../images/part01_seaborn_04.png")

---

### Scikit-learn

___Scikit-learn___ - это бесплатная библиотека машинного обучения.
Она имеет различные алгоритмы ___классификации, регрессии, кластеризации___, включая такие алгоритмы как:
* Support vector machines (SVM)
* random forests
* gradient boosting
* k-means
* DBSCAN

Также в ней содержится много алгоритмов, с помощью которых можно выполнять препроцессинг данных, который необходим для многих алгоритмов машинного обучения.
